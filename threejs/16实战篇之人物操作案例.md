# 第16课：实战篇之人物操作案例

下图是本文所分享实例最后的展示效果。本案例实现了人物跟随操作杆移动并跑步的动作，右边按钮可以实现攻击，短时间内连按可以实现不同的攻击动作。接下来我将带大家一步步实现这个案例。

![案例图片](https://images.gitbook.cn/be0cf2c0-a39e-11e8-8f3e-11f74a61cc3e)

### 场景的搭建

首先，我们需要把舞台搭建出来，先创建 Scene 场景。

#### 创建 Scene

如下代码，我们创建了场景，并将背景设置为灰色。此外，还为场景设置了雾化效果，其中的三个参数分别表示雾的颜色、雾的开始距离、完全雾化距离相机的位置。

```
scene = new THREE.Scene();
scene.background = new THREE.Color(0xa0a0a0);
scene.fog = new THREE.Fog(0xa0a0a0, 1000, 11000);
```

#### 创建 Camera

我们创建了一个与地面呈 45 度角并朝向原点的相机，代码如下：

```
camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 20000);
camera.position.set(0, 800, -800);
camera.lookAt(new THREE.Vector3());
```

#### 创建灯光

我们创建了两个灯光，分别为照射全局的环境光和可以产生阴影的平衡光。

```
scene.add(new THREE.AmbientLight(0x444444));

light = new THREE.DirectionalLight(0xaaaaaa);
light.position.set(0, 200, 100);
light.lookAt(new THREE.Vector3());

light.castShadow = true;
light.shadow.camera.top = 180;
light.shadow.camera.bottom = -180;
light.shadow.camera.left = -180;
light.shadow.camera.right = 180;

//告诉平行光需要开启阴影投射
light.castShadow = true;

scene.add(light);
```

#### 创建草地

我们使用平面几何体，创建一个草皮材质的模型：

```
var groundTexture = new THREE.TextureLoader().load('../images/grasslight-big.jpg');
groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
groundTexture.repeat.set(25, 25);
groundTexture.anisotropy = 16;
var groundMaterial = new THREE.MeshLambertMaterial({map: groundTexture});
var mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(20000, 20000), groundMaterial);
mesh.rotation.x = -Math.PI / 2;
mesh.receiveShadow = true;
scene.add(mesh);
```

到这里，场景、灯光、相机、舞台都已经备齐。接下来我们将请出我们主角 naruto 登场。

### 人物模型和动画

#### 添加人物模型

接下来主人公登场，首先我们将模型导入到场景内，注意，案例中的模型比较大，加载和处理需要一定的时间，请小伙伴们耐心等待即可。

```
var loader = new THREE.FBXLoader();
        loader.load("../js/models/fbx/Naruto.fbx", function (mesh) {
            scene.add(mesh);
        });
```

我们不单单只是将模型添加到场景，还对模型的阴影和位置做了一下调整：

```
//设置模型的每个部位都可以投影
mesh.traverse(function (child) {
    if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;
    }
});
```

调整模型的位置，使其站立在草地上面：

```
mesh.position.y += 110;
```

设置灯光一直照射模型：

```
//设置光线焦点模型
light.target = mesh;
```

#### 添加动画

这个模型里含有 27 个骨骼动画，我们可以通过设置不同的动画，实现一整套动作来实现诸如攻击、移动等效果。接下来我们通过模型数据生成所需动画：

```
actions = []; //所有的动画数组

for (var i = 0; i < mesh.animations.length; i++) {
    createAction(i);
}

function createAction(i) {
    actions[i] = mixer.clipAction(mesh.animations[i]);
    gui["action" + i] = function () {
        for (var j = 0; j < actions.length; j++) {
            if (j === i) {
                actions[j].play();
            }
            else {
                actions[j].stop();
            }
        }
    };
}

//添加暂停所有动画的按键
gui.stop = function () {
    for (var i = 0; i < actions.length; i++) {
        actions[i].stop();
    }
};
```

模型加载成功后，我们需要让模型执行一个普通的站立效果：

```
//第24个动作是鸣人站立的动作
gui["action" + 24]();
```

### 添加操作

在案例中，我们主要添加了两种操作，分别为模型位置移动操作和攻击操作。

为了方便，操作按钮直接使用 dom 标签来模拟。

模型位置移动操作中，我们需要模型位置的变动、模型的朝向以及修改站立动画和奔跑动画的切换。

攻击操作则是实现攻击，并根据点击速度，实现一整套攻击动作切换。

#### 实现位置移动效果

为了实现位置移动，我们为按钮绑定了三个事件，分别为鼠标按下、鼠标移动、鼠标抬起。

在鼠标按下时，我们获取当前操作圆盘中心点的位置，让模型进入跑步动画，并绑定鼠标移动和抬起事件。重要的是更新模型的移动方向和移动速度。

```
dop.$(control).on("down", function (event) {
    event.preventDefault();

    //获取当前的按钮中心点
    center.x = window.innerWidth - parseFloat(dop.getFinalStyle(control, "right")) - parseFloat(dop.getFinalStyle(control, "width")) / 2;
    center.y = window.innerHeight - parseFloat(dop.getFinalStyle(control, "bottom")) - parseFloat(dop.getFinalStyle(control, "height")) / 2;

    getRadian(event);

    //鼠标按下切换跑步动作
    state.skills === 0 && gui["action" + 3]();

    //给document绑定拖拽和鼠标抬起事件
    doc.on("move", move);
    doc.on("up", up);
});
```

上面的 dop 类是我封装的一个兼容多端的事件库，具体详情可以[点击这里](https://github.com/johnson2heng/dop)查看。

在鼠标移动回调事件中，我们更新模型的移动方向和移动速度。

```
function move(event) {
    getRadian(event);
}
```

最后在鼠标抬起事件中，我们解绑事件，将按键复原，并停止模型的移动状态，将模型动画恢复到站立状态。

```
function up() {
    doc.remove("move", move);
    doc.remove("up", up);

    //按钮复原
    bar.style.marginTop = 0;
    barWrap.style.transform = `translate(-50%, -50%) rotate(0deg)`;
    bar.style.transform = `translate(-50%, -50%) rotate(0deg)`;

    //设置移动距离为零
    characterMove(new THREE.Vector2(), 0);

    //鼠标抬起切换站立状态
    state.skills === 0 && gui["action" + 24]();
}
```

三个事件绑定完成后，我们需要利用回调中获得的值求出当前的偏转方向和移动速度。

首先我们获取当前鼠标的位置：

```
if (media === "pc") {
    mouse.x = event.clientX;
    mouse.y = event.clientY;
}
else {
    mouse.x = event.touches[0].clientX;
    mouse.y = event.touches[0].clientY;
}
```

根据位置求出距离操作圆盘中心的位置，并保证最大值不会超出圆盘的半径：

```
let distance = center.distanceTo(mouse);
distance >= parseFloat(dop.getFinalStyle(control, "width")) / 2 && (distance = parseFloat(dop.getFinalStyle(control, "width")) / 2);
```

计算出当前位置和中心夹角，并修改 dom 的位置：

```
//计算两点之间的夹角
mouse.x = mouse.x - center.x;
mouse.y = mouse.y - center.y;

//修改操作杆的css样式
bar.style.marginTop = `-${distance}px`;
bar.style.transform = `translate(-50%, -50%) rotate(-${(mouse.angle() / Math.PI * 180 + 90) % 360}deg)`;
barWrap.style.transform = `translate(-50%, -50%) rotate(${(mouse.angle() / Math.PI * 180 + 90) % 360}deg)`;
```

函数的最后，则调用的 `characterMove()` 方法，将按钮数据转换成模型实际需要移动的距离。

```
//修改当前的移动方向和移动速度
characterMove(mouse.normalize(), distance / (parseFloat(dop.getFinalStyle(control, "width")) / 2));
```

接下来我们查看下 `characterMove()` 方法。在该方法中，我们计算出了模型每一帧需要移动的距离。这里有一个问题，我们所谓的操作杆向前让模型移动前方，其实是相机朝向的前方。所以我们需要先求出相机的前方矢量，再以相机的前方矢量为基础，计算出来模型实际方向。

我们首先声明了两个变量，一个是旋转矩阵，另一个是移动矢量：

```
let direction = new THREE.Matrix4(); //当前移动的旋转矩阵
let move = new THREE.Vector3(); //当前位置移动的距离
```

在 `characterMove()` 函数内，我们根据相机的四元数获得了旋转矩阵：

```
//重置矩阵
direction.identity();

//通过相机的四元数获取到相机的旋转矩阵
let quaternion = camera.quaternion;
direction.makeRotationFromQuaternion(quaternion);
```

然后通过旋转矩阵和当前操作杆的方向相乘计算出实际模型移动的方向：

```
//获取到操作杆的移动方向
move.x = vector.x;
move.y = 0;
move.z = vector.y;

//通过相机方向和操作杆获得最终角色的移动方向
move.applyMatrix4(direction);
move.normalize();
```

最后，通过比例和方向得出当前模型每一帧移动的距离。我们不需要修改模型 y 轴，只修改了 x、y 两个轴的位置：

```
move.x = move.x * ratio * 10;
move.z = move.z * ratio * 10;
```

我们获取了模型每一帧移动的距离，还需要在帧循环中调用：

```
//如果模型添加成功，则每帧都移动角色位置
if (naruto) {
    //获取当前位置
    position.x += move.x;
    position.z += move.z;

    //修改模型位置
    naruto.position.x = position.x;
    naruto.position.z = position.z;

    //修改平衡光的位置
    light.position.x = position.x;
    light.position.z = position.z + 100;

    //修改相机位置
    camera.position.x = position.x;
    camera.position.z = position.z - 800;
}
```

当前的模型、灯光和相机都会跟随移动，实现了我们上面动图中的模型移动效果。

#### 实现攻击效果

在实现攻击效果时，我并没有简单地实现一个普通的攻击，而是实现了一套连环招。

这套连环招由五个动作组成，在执行一个攻击动画时，如果再次点击攻击按钮，执行完该攻击动画后，不会切换到站立动画，而是直接切换到连环招的下一个攻击动画。

只要连续单击攻击按钮，模型将完成一整套的动作。实现这个效果，我们只需一个简单的定时器，接下来我们通过代码了解实现过程。

在实现动画前，先设置一个连环招的数组，将需要的动作添加到数组当中。我这里添加了五个手部攻击的效果：

```
let attackList = [12, 13, 14, 15, 16]; //连招的循序
let attackCombo = false; //是否连招，接下一个攻击
```

我们还定义了 attackCombo 变量，用来设置是否使用连环招。变量 `state.skills` 值不为 0 时，它将变为 True。定时器每一次更新时，将判断 attackCombo 是否为 True，在 True 的状态下，将执行连环招的下一个动作。否则，将停止连环招。

```
//attackIndex 等于0，当前不处于攻击状态  不等于，当前处于攻击状态
if(state.skills === 0){
    state.skills++;
    gui["action" + attackList[state.skills-1]]();
    attackInterval = setInterval(function () {
        if(attackCombo){
            //如果设置了连招，上一个攻击动作完成后，进行下一个攻击动作
            state.skills++;
            //如果整套攻击动作已经执行完成，则清除定时器
            if(state.skills-1 >= attackList.length){
                closeAttack();
                return;
            }

            //进行下一个动作
            gui["action" + attackList[state.skills-1]]();

            attackCombo = false;
        }
        else{
            closeAttack();
        }
    }, naruto.animations[attackList[state.skills-1]].duration*1000);
}
else{
    attackCombo = true;
}
```

在关闭攻击动画的函数内，我们首先将 `state.skills` 设置为 0，然后恢复到移动或者站立动画，最后清除掉定时器：

```
//关闭攻击状态
function closeAttack() {
    state.skills = 0;
    //根据状态设置是移动状态还是站立状态
    state.move ? gui["action" + 3]() :gui["action" + 24](); //回到站立状态
    clearInterval(attackInterval);
}
```

通过很简单的一些代码，我们就实现了一个复杂的连环招效果。

最后，奉上案例查看页面：[点击这里](https://johnson2heng.github.io/GitChat-Three.js/16 简单案例/demo.html)。